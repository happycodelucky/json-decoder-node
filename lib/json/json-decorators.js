"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonNotify = exports.jsonDecoderCompleted = exports.jsonDecoder = exports.jsonDecoderFactory = exports.jsonType = exports.jsonPropertyAlias = exports.jsonProperty = exports.jsonContext = exports.jsonSchema = exports.jsonDecodable = void 0;
require("reflect-metadata");
const createDebugLog = require("debug");
const decoder_declarations_1 = require("../decoder/decoder-declarations");
const decoder_declarations_2 = require("../decoder/decoder-declarations");
const decoder_map_1 = require("../decoder/decoder-map");
const json_symbols_1 = require("./json-symbols");
const debug = createDebugLog('decoder:json');
function jsonDecodable(options) {
    return (target) => {
        debug(`${target.name} applying jsonDecodable with options ${JSON.stringify(options)}`);
        Reflect.defineMetadata(decoder_declarations_1.DecoderMetadataKeys.decodable, true, target);
        const decodableOptions = Object.assign({}, options);
        Reflect.defineMetadata(decoder_declarations_1.DecoderMetadataKeys.decodableOptions, decodableOptions, target);
        return target;
    };
}
exports.jsonDecodable = jsonDecodable;
function jsonSchema(schema, ...references) {
    return (target) => {
        debug(`${target.name} applying jsonSchema`);
        const schemaMetadata = {
            schema,
            references,
        };
        Reflect.defineMetadata(json_symbols_1.JsonDecoderMetadataKeys.schema, schemaMetadata, target);
        return target;
    };
}
exports.jsonSchema = jsonSchema;
function jsonContext(target, key) {
    debug(`${target.constructor.name} applying jsonContext to ${key}`);
    Reflect.defineMetadata(json_symbols_1.JsonDecoderMetadataKeys.context, key, target.constructor);
    const descriptor = Reflect.getOwnPropertyDescriptor(target, key);
    Reflect.defineProperty(target, key, {
        configurable: true,
        writable: true,
        enumerable: false,
        value: !!descriptor ? descriptor.value : undefined,
    });
    if (!('toJSON' in target)) {
        target['toJSON'] = function toJSON() {
            return Object.assign({}, this[key]);
        };
    }
}
exports.jsonContext = jsonContext;
function jsonProperty(target, key) {
    debug(`${target.constructor.name} applying jsonProperty to ${key}`);
    const decoderMap = decoder_map_1.decoderMapEntryForTarget(key, target.constructor);
    if (typeof decoderMap.key !== 'string' || decoderMap.key.length === 0) {
        decoderMap.key = key;
    }
}
exports.jsonProperty = jsonProperty;
function jsonPropertyAlias(keyPath) {
    if (typeof keyPath !== 'string' || keyPath.length === 0) {
        throw new TypeError('jsonProperty(keyPath) should be a non-empty String');
    }
    return (target, key) => {
        const decoderMap = decoder_map_1.decoderMapEntryForTarget(key, target.constructor);
        decoderMap.key = keyPath;
    };
}
exports.jsonPropertyAlias = jsonPropertyAlias;
function jsonType(type, mapFunction) {
    if (Array.isArray(type) && type.length !== 1) {
        throw new TypeError('jsonType(type) should have exactly one element for Array types');
    }
    return (target, key) => {
        const decoderMapEntry = decoder_map_1.decoderMapEntryForTarget(key, target.constructor);
        const elementType = decoder_declarations_2.isDecoderPrototypalCollectionTarget(type) ? type.collection : type;
        debug(`${target.constructor.name} applying jsonType to ${key}, marshalling using ${elementType.name}`);
        decoderMapEntry.type = type;
        decoderMapEntry.mapFunction = mapFunction;
    };
}
exports.jsonType = jsonType;
function jsonDecoderFactory(target, key, descriptor) {
    debug(`${target.name} applying jsonDecoderFactory to ${key}`);
    Reflect.defineMetadata(decoder_declarations_1.DecoderMetadataKeys.decoderFactory, target[key], target);
    return descriptor;
}
exports.jsonDecoderFactory = jsonDecoderFactory;
function jsonDecoder(target, key, descriptor) {
    debug(`${target.constructor.name} applying jsonDecoder to ${key}`);
    Reflect.defineMetadata(decoder_declarations_1.DecoderMetadataKeys.decoder, target[key], target);
    return descriptor;
}
exports.jsonDecoder = jsonDecoder;
function jsonDecoderCompleted(target, key, descriptor) {
    debug(`${target.constructor.name} applying jsonDecoderCompleted to ${key}`);
    Reflect.defineMetadata(decoder_declarations_1.DecoderMetadataKeys.decoderCompleted, target[key], target);
    return descriptor;
}
exports.jsonDecoderCompleted = jsonDecoderCompleted;
function jsonNotify(keyPath, type) {
    if (typeof keyPath !== 'string') {
        throw new TypeError('jsonPropertyHandler(keyPath) should be a non-empty String');
    }
    if (Array.isArray(type) && type.length !== 1) {
        throw new TypeError('jsonPropertyHandler(type) should have exactly one element for Array types');
    }
    return (target, key, descriptor) => {
        debug(`${target.constructor.name} applying jsonPropertyHandler ${keyPath} to ${key}`);
        let notifiers = Reflect.getOwnMetadata(decoder_declarations_1.DecoderMetadataKeys.decoderNotifiers, target.constructor);
        if (!notifiers) {
            notifiers = new Map();
            Reflect.defineMetadata(decoder_declarations_1.DecoderMetadataKeys.decoderNotifiers, notifiers, target.constructor);
        }
        let propertyNotifiers = notifiers.get(keyPath);
        if (!propertyNotifiers) {
            propertyNotifiers = [];
            notifiers.set(keyPath, propertyNotifiers);
        }
        propertyNotifiers.push({
            key: keyPath,
            type,
            mapFunction: descriptor.value,
        });
        return descriptor;
    };
}
exports.jsonNotify = jsonNotify;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNvbi1kZWNvcmF0b3JzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2pzb24vanNvbi1kZWNvcmF0b3JzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUlBLDRCQUF5QjtBQUV6Qix3Q0FBdUM7QUFFdkMsMEVBQTBIO0FBQzFILDBFQUF3SDtBQUN4SCx3REFBa0Y7QUFFbEYsaURBQXdEO0FBR3hELE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQTtBQTJCNUMsU0FBZ0IsYUFBYSxDQUFDLE9BQThCO0lBQ3hELE9BQU8sQ0FBb0MsTUFBUyxFQUF1QixFQUFFO1FBQ3pFLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLHdDQUF3QyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQTtRQUN0RixPQUFPLENBQUMsY0FBYyxDQUFDLDBDQUFtQixDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUE7UUFHbkUsTUFBTSxnQkFBZ0IscUJBQTZCLE9BQU8sQ0FBQyxDQUFBO1FBQzNELE9BQU8sQ0FBQyxjQUFjLENBQUMsMENBQW1CLENBQUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxDQUFDLENBQUE7UUFLdEYsT0FBNkIsTUFBTSxDQUFBO0lBQ3ZDLENBQUMsQ0FBQTtBQUNMLENBQUM7QUFkRCxzQ0FjQztBQTBCRCxTQUFnQixVQUFVLENBQUMsTUFBMkIsRUFBRSxHQUFHLFVBQTZEO0lBQ3BILE9BQU8sQ0FBb0MsTUFBUyxFQUFLLEVBQUU7UUFDdkQsS0FBSyxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksc0JBQXNCLENBQUMsQ0FBQTtRQUMzQyxNQUFNLGNBQWMsR0FBOEI7WUFDOUMsTUFBTTtZQUNOLFVBQVU7U0FDYixDQUFBO1FBQ0QsT0FBTyxDQUFDLGNBQWMsQ0FBQyxzQ0FBdUIsQ0FBQyxNQUFNLEVBQUUsY0FBYyxFQUFFLE1BQU0sQ0FB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QVUsQ0FBQTtJQUNyQixDQUFDLENBQUE7QUFDTCxDQUFDO0FBakNELGdDQWlDQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGVjb3JhdG9ycyB0byBkZWNsYXJlIG9uIEpTT04gZGVjb2RhYmxlIGNsYXNzZXMsIHByb3BlcnRpZXMsIGFuZCBmdW5jdGlvbnNcbiAqL1xuXG5pbXBvcnQgJ3JlZmxlY3QtbWV0YWRhdGEnXG5cbmltcG9ydCAqIGFzIGNyZWF0ZURlYnVnTG9nIGZyb20gJ2RlYnVnJ1xuXG5pbXBvcnQgeyBEZWNvZGVyQ29uc3RydWN0YWJsZVRhcmdldCwgRGVjb2Rlck1ldGFkYXRhS2V5cywgRGVjb2RlclByb3RvdHlwYWxUYXJnZXQgfSBmcm9tICcuLi9kZWNvZGVyL2RlY29kZXItZGVjbGFyYXRpb25zJ1xuaW1wb3J0IHsgRGVjb2RlclByb3RvdHlwYWxDb2xsZWN0aW9uVGFyZ2V0LCBpc0RlY29kZXJQcm90b3R5cGFsQ29sbGVjdGlvblRhcmdldCB9IGZyb20gJy4uL2RlY29kZXIvZGVjb2Rlci1kZWNsYXJhdGlvbnMnXG5pbXBvcnQgeyBEZWNvZGVyTWFwRW50cnksIGRlY29kZXJNYXBFbnRyeUZvclRhcmdldCB9IGZyb20gJy4uL2RlY29kZXIvZGVjb2Rlci1tYXAnXG5pbXBvcnQgeyBKc29uQ29udmVydGFibGUsIEpzb25PYmplY3QgfSBmcm9tICcuL2pzb24tZGVjb2RhYmxlLXR5cGVzJ1xuaW1wb3J0IHsgSnNvbkRlY29kZXJNZXRhZGF0YUtleXMgfSBmcm9tICcuL2pzb24tc3ltYm9scydcblxuLy8gRGVidWcgbG9nZ2VyXG5jb25zdCBkZWJ1ZyA9IGNyZWF0ZURlYnVnTG9nKCdkZWNvZGVyOmpzb24nKVxuXG4vL1xuLy8gQ2xhc3MgZGVjb3JhdG9yc1xuLy9cblxuLyoqXG4gKiBPcHRpb25zIHByb3ZpZGVkIHRvIGEgYGpzb25EZWNvZGFibGVgIGNsYXNzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSnNvbkRlY29kYWJsZU9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIFN0cmljdCBtb2RlXG4gICAgICovXG4gICAgc3RyaWN0PzogYm9vbGVhblxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlIHdpbGwgY2FsbCB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24gKGRlZmF1bHQpXG4gICAgICogSWYgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpcyBub3QgdGhlbiBubyBUeXBlU2NyaXB0IGluaXRpYWxpemF0aW9uIG9mIHByb3BlcnRpZXMgaXMgcGVyZm9ybWVkXG4gICAgICovXG4gICAgdXNlQ29uc3RydWN0b3I/OiBib29sZWFuXG59XG5cbi8qKlxuICogRGVjbGFyZSBhIGNsYXNzIGFzIGJlaW5nIGRlY29kYWJsZSBmcm9tIGEgSlNPTiBvYmplY3RcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIGRlY29kZXIgb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24ganNvbkRlY29kYWJsZShvcHRpb25zPzogSnNvbkRlY29kYWJsZU9wdGlvbnMpIHtcbiAgICByZXR1cm4gPFQgZXh0ZW5kcyBEZWNvZGVyUHJvdG90eXBhbFRhcmdldD4odGFyZ2V0OiBUKTogVCAmIEpzb25Db252ZXJ0YWJsZSA9PiB7XG4gICAgICAgIGRlYnVnKGAke3RhcmdldC5uYW1lfSBhcHBseWluZyBqc29uRGVjb2RhYmxlIHdpdGggb3B0aW9ucyAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMpfWApXG4gICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoRGVjb2Rlck1ldGFkYXRhS2V5cy5kZWNvZGFibGUsIHRydWUsIHRhcmdldClcblxuICAgICAgICAvLyBEZWNvZGFibGUgb3B0aW9uc1xuICAgICAgICBjb25zdCBkZWNvZGFibGVPcHRpb25zOiBKc29uRGVjb2RhYmxlT3B0aW9ucyA9IHsuLi5vcHRpb25zfVxuICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKERlY29kZXJNZXRhZGF0YUtleXMuZGVjb2RhYmxlT3B0aW9ucywgZGVjb2RhYmxlT3B0aW9ucywgdGFyZ2V0KVxuXG4gICAgICAgIC8vIGNvbnN0IG1hcCA9IGRlY29kZXJNYXBGb3JUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgLy8gVE9ETzogT3V0cHV0IHRoZSBkZWNvZGVyIG1hcCBmb3IgdGhlIHRhcmdldC4gTmVlZHMgdG8gYmUgc2FuaXRpemUgdG8gb3V0cHV0IGNvcnJlY3RseVxuXG4gICAgICAgIHJldHVybiA8VCAmIEpzb25Db252ZXJ0YWJsZT4gdGFyZ2V0XG4gICAgfVxufVxuXG4vKipcbiAqIEpzb24gc2NoZW1hIGFzIHVzZWQgYnkgYSBKU09OIGRlY29kYWJsZSBvYmplY3RcbiAqIFRPRE86IFVzZSBhbiBpbnRlcmZhY2UgZGVzY3JpYmluZyB0aGUgc3VwcG9ydGVkIHNjaGVtYSB2ZXJzaW9uIChub3QgYXZhaWxhYmxlIGluIGFqdilcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBKc29uRGVjb2RhYmxlU2NoZW1hIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgJHNjaGVtYTogc3RyaW5nXG4gICAgJGlkPzogc3RyaW5nXG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBzY2hlbWEgbWV0YWRhdGEgc2V0IG9uIGEgdGFyZ2V0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSnNvbkRlY29kZXJTY2hlbWFNZXRhZGF0YSB7XG4gICAgc2NoZW1hOiBKc29uRGVjb2RhYmxlU2NoZW1hLFxuICAgIHJlZmVyZW5jZXM/OiAoSnNvbkRlY29kYWJsZVNjaGVtYSB8IERlY29kZXJQcm90b3R5cGFsVGFyZ2V0KVtdXG59XG5cbi8qKlxuICogQW4gYXNzb2NpYXRlZCBKU09OIHNjaGVtYSB0byB2YWxpZGF0ZSB0aGUgSlNPTiB3aXRoIGJlZm9yZSBkZWNvZGluZ1xuICogU2VlIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvXG4gKlxuICogQHBhcmFtIHNjaGVtYSAtIEpTT04gc2NoZW1hIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSByZWZlcmVuY2VzIC0gSlNPTiBkZWNvZGFibGUgY2xhc3NlcyBvciBzY2hlbWEgcmVmZXJlbmNlc1xuICovXG5leHBvcnQgZnVuY3Rpb24ganNvblNjaGVtYShzY2hlbWE6IEpzb25EZWNvZGFibGVTY2hlbWEsIC4uLnJlZmVyZW5jZXM6IChKc29uRGVjb2RhYmxlU2NoZW1hIHwgRGVjb2RlclByb3RvdHlwYWxUYXJnZXQpW10pIHtcbiAgICByZXR1cm4gPFQgZXh0ZW5kcyBEZWNvZGVyUHJvdG90eXBhbFRhcmdldD4odGFyZ2V0OiBUKTogVCA9PiB7XG4gICAgICAgIGRlYnVnKGAke3RhcmdldC5uYW1lfSBhcHBseWluZyBqc29uU2NoZW1hYClcbiAgICAgICAgY29uc3Qgc2NoZW1hTWV0YWRhdGE6IEpzb25EZWNvZGVyU2NoZW1hTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICByZWZlcmVuY2VzLFxuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoSnNvbkRlY29kZXJNZXRhZGF0YUtleXMuc2NoZW1hLCBzY2hlbWFNZXRhZGF0YSwgdGFyZ2V0KVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9XG59XG5cbi8vXG4vLyBQcm9wZXJ0eSBkZWNvcmF0b3JzXG4vL1xuXG4vKipcbiAqIEpTT04gY29udGV4dCBvYmplY3QgKHRoZSBvcmlnaW4gSlNPTikgYXNzaWduZWQgdG8gZGVjb2Rpbmcgb2JqZWN0XG4gKiBBbHNvIGFkZGVzIGB0b0pTT04oKWAgdG8gcmV0dXJuIHRoZSBkZWNvZGVkIG9iamVjdCBiYWNrXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gU2V0cyB0aGUgb3JpZ2luIEpTT04gdG8gYSBkZXNpZ25hdGVkIGNvbnRleHQgcHJvcGVydHlcbiAqICAgQGpzb25Db250ZXh0XG4gKiAgIHByaXZhdGUganNvbjogSnNvbk9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24ganNvbkNvbnRleHQ8VCBleHRlbmRzIERlY29kZXJDb25zdHJ1Y3RhYmxlVGFyZ2V0ICYgeyB0b0pTT04oKTogSnNvbk9iamVjdCB9Pih0YXJnZXQ6IFQsIGtleTogc3RyaW5nKSB7XG4gICAgZGVidWcoYCR7dGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWV9IGFwcGx5aW5nIGpzb25Db250ZXh0IHRvICR7a2V5fWApXG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShKc29uRGVjb2Rlck1ldGFkYXRhS2V5cy5jb250ZXh0LCBrZXksIHRhcmdldC5jb25zdHJ1Y3RvcilcblxuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSlcbiAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogISFkZXNjcmlwdG9yID8gZGVzY3JpcHRvci52YWx1ZSA6IHVuZGVmaW5lZCxcbiAgICB9KVxuXG4gICAgLy8gZGVmaW5lZCB0b0pTT04gaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICAgIGlmICghKCd0b0pTT04nIGluIHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0Wyd0b0pTT04nXSA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB7Li4udGhpc1trZXldfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIERlY2xhcmVzIGEgSlNPTiBkZWNvZGFibGUgcHJvcGVydHlcbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBVc2VzICdpbmRleCcgZnJvbSBKU09OXG4gKiAgIEBqc29uUHJvcGVydHkoKVxuICogICBwcml2YXRlIGluZGV4OiBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25Qcm9wZXJ0eTxUIGV4dGVuZHMgRGVjb2RlckNvbnN0cnVjdGFibGVUYXJnZXQ+KHRhcmdldDogVCwga2V5OiBzdHJpbmcpIHtcbiAgICBkZWJ1ZyhgJHt0YXJnZXQuY29uc3RydWN0b3IubmFtZX0gYXBwbHlpbmcganNvblByb3BlcnR5IHRvICR7a2V5fWApXG5cbiAgICBjb25zdCBkZWNvZGVyTWFwID0gZGVjb2Rlck1hcEVudHJ5Rm9yVGFyZ2V0KGtleSwgdGFyZ2V0LmNvbnN0cnVjdG9yKTtcbiAgICBpZiAodHlwZW9mIGRlY29kZXJNYXAua2V5ICE9PSAnc3RyaW5nJyB8fCBkZWNvZGVyTWFwLmtleS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVjb2Rlck1hcC5rZXkgPSBrZXlcbiAgICB9XG59XG5cbi8qKlxuICogRGVjbGFyZXMgYSBKU09OIGRlY29kYWJsZSBwcm9wZXJ0eSB3aXRoIG9wdGlvbmFsIGtleS9rZXktcGF0aCBhbGlhc1xuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIFVzZXMgJ2luZGV4JyBmcm9tIEpTT04sIGFzc2lnbmVkIHRvICdfaW5kZXgnXG4gKiAgIEBqc29uUGF0aCgnaW5kZXgnKVxuICogICBwcml2YXRlIF9pbmRleDogbnVtYmVyXG4gKlxuICogICAvLyBVc2VzICdpbmRleGVzJyBmcm9tIEpTT04sIHRha2luZyB0aGUgYXJyYXkgdmFsdWUncyAwIGluZGV4XG4gKiAgIEBqc29uUGF0aCgnaW5kZXhlc1swXScpIC0gb3IgLSBAanNvblBhdGgoJ2luZGV4ZXNAMCcpXG4gKiAgIHByaXZhdGUgaW5kZXg6IG51bWJlclxuICpcbiAqICAgLy8gVXNlcyAndGFyZ2V0OiB7IGluZGV4IH0nIGZyb20gSlNPTlxuICogICBAanNvblBhdGgoJ3RhcmdldC5pbmRleCcpXG4gKiAgIHByaXZhdGUgaW5kZXg6IG51bWJlclxuICpcbiAqIEBwYXJhbSBrZXlQYXRoIC0gcGF0aCB0byB0aGUgcHJvcGVydHksIG9yIHVuZGVmaW5lZCB0byB1c2UgcHJvcGVydHkgbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24ganNvblByb3BlcnR5QWxpYXMoa2V5UGF0aDogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJyB8fCBrZXlQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdqc29uUHJvcGVydHkoa2V5UGF0aCkgc2hvdWxkIGJlIGEgbm9uLWVtcHR5IFN0cmluZycpXG4gICAgfVxuXG4gICAgcmV0dXJuICh0YXJnZXQ6IERlY29kZXJDb25zdHJ1Y3RhYmxlVGFyZ2V0LCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBkZWNvZGVyTWFwID0gZGVjb2Rlck1hcEVudHJ5Rm9yVGFyZ2V0KGtleSwgdGFyZ2V0LmNvbnN0cnVjdG9yKVxuICAgICAgICAvLyBUT0RPOiBDb21waWxlIHRoZSBwYXRoIGhlcmUgaW5zdGVhZCBvZiBlYWNoIGRlY29kZVxuICAgICAgICBkZWNvZGVyTWFwLmtleSA9IGtleVBhdGhcbiAgICB9XG59XG5cbi8qKlxuICogQXV0b21hdGljYWxseSBtYXBzIChtYXJzaGFscykgYSB2YWx1ZSBmcm9tIGEgSlNPTiBwcm9wZXJ0eSB2YWx1ZSBpbnRvIGEgZGVzaXJlZCB0eXBlXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gRW5zdXJlcyBhIE51bWJlciB2YWx1ZSB3aWxsIGJlIGFzc2lnbmVkIHRvICdpbmRleCcsIG1hcHBlZCBhcHByb3ByaWF0ZWx5XG4gKiAgIEBqc29uUHJvcGVydHkoKVxuICogICBAanNvblR5cGUoTnVtYmVyKVxuICogICBwcml2YXRlIGluZGV4OiBudW1iZXJcbiAqXG4gKiAgIC8vIEVuc3VyZXMgYSBVUkwgdmFsdWUgd2lsbCBiZSBhc3NpZ25lZCB0byAnZW5kcG9pbnQnLCBtYXJzaGFsbGVkIGZyb20gYSBzdHJpbmcgYXBwcm9wcmlhdGVseVxuICogICBAanNvblByb3BlcnR5KClcbiAqICAgQGpzb25UeXBlKFVSTClcbiAqICAgcHJpdmF0ZSBpbmRleDogVVJMXG4gKlxuICogICAvLyBFbnN1cmVzIHRoZSBkZWNvZGVkIHZhbHVlIHdpbGwgYmUgYSBzdHJpbmcsIGFuZCB1c2VzIHRoZSBzdHJpbmcgd2l0aCBhIGN1c3RvbSBtYXAgZnVuY3Rpb25cbiAqICAgQGpzb25Qcm9wZXJ0eSgpXG4gKiAgIEBqc29uVHlwZShTdHJpbmcsICh2YWx1ZTogc3RyaW5nKSA9PiBuZXcgUmVnRXguY29tcGlsZSh2YWx1ZSkpXG4gKiAgIHByaXZhdGUgcGF0dGVybjogUmVnRXhcbiAqXG4gKiBAcGFyYW0gdHlwZSAtIG1hcnNoYWxsYWJsZSB0eXBlXG4gKiBAcGFyYW0gW21hcEZ1bmN0aW9uXSAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRha2luZyBhbiBpbnN0YW5jZSBvZiBgdHlwZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25UeXBlKFxuICAgIHR5cGU6IERlY29kZXJQcm90b3R5cGFsVGFyZ2V0IHwgRGVjb2RlclByb3RvdHlwYWxDb2xsZWN0aW9uVGFyZ2V0LFxuICAgIG1hcEZ1bmN0aW9uPzogKHZhbHVlOiBhbnkpID0+IGFueSxcbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpICYmIHR5cGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2pzb25UeXBlKHR5cGUpIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIGVsZW1lbnQgZm9yIEFycmF5IHR5cGVzJylcbiAgICB9XG5cbiAgICByZXR1cm4gKHRhcmdldDogRGVjb2RlckNvbnN0cnVjdGFibGVUYXJnZXQsIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlY29kZXJNYXBFbnRyeSA9IGRlY29kZXJNYXBFbnRyeUZvclRhcmdldChrZXksIHRhcmdldC5jb25zdHJ1Y3RvcilcblxuICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9IGlzRGVjb2RlclByb3RvdHlwYWxDb2xsZWN0aW9uVGFyZ2V0KHR5cGUpID8gdHlwZS5jb2xsZWN0aW9uIDogdHlwZVxuICAgICAgICBkZWJ1ZyhgJHt0YXJnZXQuY29uc3RydWN0b3IubmFtZX0gYXBwbHlpbmcganNvblR5cGUgdG8gJHtrZXl9LCBtYXJzaGFsbGluZyB1c2luZyAke2VsZW1lbnRUeXBlLm5hbWV9YClcblxuICAgICAgICBkZWNvZGVyTWFwRW50cnkudHlwZSA9IHR5cGVcbiAgICAgICAgZGVjb2Rlck1hcEVudHJ5Lm1hcEZ1bmN0aW9uID0gbWFwRnVuY3Rpb25cbiAgICB9XG59XG5cbi8vXG4vLyBGdW5jdGlvbiBkZWNvcmF0b3JzXG4vL1xuXG4vKipcbiAqIERlY2xhcmVzIGEgZnVuY3Rpb24gYXMgYmVpbmcgdGhlIGRlY29kZXIgY2xhc3MgZmFjdG9yeSwgcmV0dXJuaW5nIHRoZSBjbGFzcyB0byBpbnN0YW50aWF0ZSB3aXRoIHRoZSBKU09OIGRlY29kZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogICBAanNvbkRlY29kZXJGYWN0b3J5XG4gKiAgIHN0YXRpYyBkZWNvZGVyQ2xhc3NGYWN0b3J5KGpzb246IEpzb25PYmplY3QpIHtcbiAqICAgICAgIC8vIElmICd0eXBlJyBpcyAnc3BlY2lhbCcgaW4gb3VyIEpTT04gb2JqZWN0LCByZXR1cm4gTXlTcGVjaWFsQ2xhc3MgdG8gZGVjb2RlXG4gKiAgICAgICBpZiAoJ3R5cGUnIGluIGpzb24gJiYganNvbi50eXBlID09PSAnc3BlY2lhbCcpIHtcbiAqICAgICAgICAgICByZXR1cm4gbmV3IE15U3BlY2lhbENsYXNzKClcbiAqICAgICAgIH1cbiAqXG4gKiAgICAgICByZXR1cm4gTXlDbGFzcygpXG4gKiAgIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25EZWNvZGVyRmFjdG9yeSh0YXJnZXQ6IERlY29kZXJQcm90b3R5cGFsVGFyZ2V0LCBrZXk6IHN0cmluZywgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKTogUHJvcGVydHlEZXNjcmlwdG9yIHtcbiAgICBkZWJ1ZyhgJHt0YXJnZXQubmFtZX0gYXBwbHlpbmcganNvbkRlY29kZXJGYWN0b3J5IHRvICR7a2V5fWApXG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShEZWNvZGVyTWV0YWRhdGFLZXlzLmRlY29kZXJGYWN0b3J5LCB0YXJnZXRba2V5XSwgdGFyZ2V0KVxuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3Jcbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGRlY29kZXIgZnVuY3Rpb24uIFRoaXMgZGVjb3JhdGlvbiBiZWhhdmVzIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB0aGUgcGxhY2VtZW50IG9uIHRoZVxuICogY2xhc3Moc3RhdGljIGZ1bmN0aW9uKS9jb25zdHJ1Y3RvciBmdW5jdGlvbiBpdHNlbGYsIG9yIG9uIHRoZSBjbGFzcyBwcm90b3R5cGUuIEJvdGggbWF5IGJlIHVzZWQsIGlmIGRlc2lyZWQuXG4gKiBJbiBib3RoIGNhc2UgdGhlIHNvdXJjZSBKU09OIG9iamVjdCB3aWxsIGJlIHN1cHBsaWVkIHRvIGFpZCBkZWNvZGluZy5cbiAqXG4gKiBXaGVuIGFwcGxpZWQgdG8gdGhlIGNsYXNzIChzdGF0aWMgZnVuY3Rpb24pIHRoZSBkZWNvZGVyIGZ1bmN0aW9uIG11c3QgcmV0dXJuIHRoZSBkZWNvZGVkIG9iamVjdCwgb3IgaW5pdGlhbGl6ZVxuICogYW5kIG9iamVjdCB0byBiZWdpbiBkZWNvZGluZy4gUmV0dXJuaW5nIHVuZGVmaW5lZCB3aWxsIGZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0IG9iamVjdCBjcmVhdGlvbiwgcmV0dXJuaW5nIG51bGwgd2lsbFxuICogaW52YWxpZGF0ZSBkZWNvZGluZy5cbiAqXG4gKiBXaGVuIGFwcGxpZWQgdG8gYSBwcm90b3R5cGUgZnVuY3Rpb24sIHRoZSBkZWNvZGluZyBvYmplY3Qgd2lsbCBoYXZlIGJlZW4gY3JlYXRlZC4gVGhlIGZ1bmN0aW9uIG11c3QgcmV0dXJuIHRoaXMgb3JcbiAqIGEgcmVwbGFjZW1lbnQgb2JqZWN0LiBSZXR1cm5pbmcgdW5kZWZpbmVkIHdpbGwgZmFsbGJhY2sgYW5kIHVzZSB0aGUgc2FtZSBkZWNvZGluZyBvYmplY3QgYWxyZWFkeSBjcmVhdGVkLCByZXR1cm5pbmdcbiAqIG51bGxsIHdpbGwgaW52YWxpZGF0ZSB0aGUgZGVjb2RpbmcuXG4gKlxuICogRXJyb3JzIHRocm93biBoZXJlIHdpbGwgYmUgcHJvcGFnYXRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAgIEBqc29uRGVjb2RlclxuICogICBwdWJsaWMgZGVjb2Rlcihqc29uOiBPYmplY3QpOiBNeUNsYXNzIHwgbnVsbCB7IC4uLiB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc29uRGVjb2Rlcih0YXJnZXQ6IERlY29kZXJDb25zdHJ1Y3RhYmxlVGFyZ2V0LCBrZXk6IHN0cmluZywgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKTogUHJvcGVydHlEZXNjcmlwdG9yIHtcbiAgICBkZWJ1ZyhgJHt0YXJnZXQuY29uc3RydWN0b3IubmFtZX0gYXBwbHlpbmcganNvbkRlY29kZXIgdG8gJHtrZXl9YClcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKERlY29kZXJNZXRhZGF0YUtleXMuZGVjb2RlciwgdGFyZ2V0W2tleV0sIHRhcmdldClcblxuICAgIHJldHVybiBkZXNjcmlwdG9yXG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBmdW5jdGlvbiBjYWxsZWQgb24gdGhlIGRlY29kZWQgb2JqZWN0IHdoZW4gZGVjb2RpbmcgaGFzIGNvbXBsZXRlZC4gQXQgdGhpcyBwb2ludCBhbGwgcHJvcGVydGllcyBoYXZlXG4gKiBiZWVuIGFzc2lnbmVkLCBhbmQgYWxsIHByb3BlcnR5IGhhbmRsZXIgZnVuY3Rpb25zIGNhbGxlZC4gYGpzb25EZWNvZGVyQ29tcGxldGVkYCBvbmx5IGNhbiBiZSBjYWxsZWQgb24gcHJvdG90eXBlXG4gKiBmdW5jdGlvbnMsIGFuZCBwcm92aWRlcyBhIGxhc3QgY2hhbmNlIHRvIHBlcmZvcm0gYW55IGFkZGl0aW9uYWwgZGVjb2RpbmcsIHZhbGlkYXRpb24sIG9yIGludmFsaWRhdGlvbi5cbiAqXG4gKiBMaWtlIGBqc29uRGVjb2RlcmAgcmV0dXJuaW5nIGBudWxsYCBpbnZhbGlkYXRlcyB0aGUgZGVjb2RlZCBvYmplY3QuXG4gKlxuICogRXJyb3JzIHRocm93biBoZXJlIHdpbGwgYmUgcHJvcGFnYXRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAgIEBqc29uRGVjb2RlckNvbXBsZXRlXG4gKiAgIGZ1bmN0aW9uIGRlY29kZXIoanNvbjogT2JqZWN0KTogTXlDbGFzcyB8IG51bGwgeyAuLi4gfVxuICovXG5leHBvcnQgZnVuY3Rpb24ganNvbkRlY29kZXJDb21wbGV0ZWQodGFyZ2V0OiBEZWNvZGVyQ29uc3RydWN0YWJsZVRhcmdldCwga2V5OiBzdHJpbmcsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcik6IFByb3BlcnR5RGVzY3JpcHRvciB7XG4gICAgZGVidWcoYCR7dGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWV9IGFwcGx5aW5nIGpzb25EZWNvZGVyQ29tcGxldGVkIHRvICR7a2V5fWApXG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShEZWNvZGVyTWV0YWRhdGFLZXlzLmRlY29kZXJDb21wbGV0ZWQsIHRhcmdldFtrZXldLCB0YXJnZXQpXG5cbiAgICByZXR1cm4gZGVzY3JpcHRvclxufVxuXG4vKipcbiAqIEFzc29jaWF0ZXMgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhIEpTT04gcHJvcGVydHkgb2YgYSBnaXZlbiBrZXkgcGF0aCBpcyBmb3VuZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICBqc29uTm90aWZ5KCdpbmRleCcsIE51bWJlcilcbiAqICAgcHJpdmF0ZSBvbkluZGV4KGluZGV4OiBudW1iZXIsIGpzb246IEpzb25PYmplY3QpIHtcbiAqICAgICAvLyBEbyBzb21ldGhpbmcgd2l0aCBpbmRleFxuICogICAgIC8vICd0aGlzJyBpcyBzZXQgdG8gdGhlIG9iamVjdCBiZWluZyBjb2RlZFxuICogICB9XG4gKlxuICogQHBhcmFtIGtleVBhdGggLSBrZXkgcGF0aCB0byB0aGUgcHJvcGVydHkgZnJvbSB0aGUgcm9vdCBmb3IgdGhlIEpTT05cbiAqIEBwYXJhbSBbdHlwZT11bmRlZmluZWRdIC0gdHlwZSBkZWNsYXJhdGlvbiBzaW1pbGFyIHRvIGpzb25UeXBlIHRvIGF1dG9tYXRpY2FsbHkgbWFwIHRoZSBwcm9wZXJ0eSB0b1xuICovXG5leHBvcnQgZnVuY3Rpb24ganNvbk5vdGlmeShrZXlQYXRoOiBzdHJpbmcsIHR5cGU/OiBEZWNvZGVyUHJvdG90eXBhbFRhcmdldCB8IERlY29kZXJQcm90b3R5cGFsQ29sbGVjdGlvblRhcmdldCkge1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignanNvblByb3BlcnR5SGFuZGxlcihrZXlQYXRoKSBzaG91bGQgYmUgYSBub24tZW1wdHkgU3RyaW5nJylcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkgJiYgdHlwZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignanNvblByb3BlcnR5SGFuZGxlcih0eXBlKSBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBlbGVtZW50IGZvciBBcnJheSB0eXBlcycpXG4gICAgfVxuXG4gICAgcmV0dXJuIDxUIGV4dGVuZHMgRGVjb2RlckNvbnN0cnVjdGFibGVUYXJnZXQ+KHRhcmdldDogVCwga2V5OiBzdHJpbmcsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcik6IFByb3BlcnR5RGVzY3JpcHRvciA9PiB7XG4gICAgICAgIGRlYnVnKGAke3RhcmdldC5jb25zdHJ1Y3Rvci5uYW1lfSBhcHBseWluZyBqc29uUHJvcGVydHlIYW5kbGVyICR7a2V5UGF0aH0gdG8gJHtrZXl9YClcblxuICAgICAgICBsZXQgbm90aWZpZXJzID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcbiAgICAgICAgICAgIERlY29kZXJNZXRhZGF0YUtleXMuZGVjb2Rlck5vdGlmaWVycyxcbiAgICAgICAgICAgIHRhcmdldC5jb25zdHJ1Y3RvcixcbiAgICAgICAgKSBhcyBNYXA8c3RyaW5nLCBEZWNvZGVyTWFwRW50cnlbXT4gfCB1bmRlZmluZWRcblxuICAgICAgICBpZiAoIW5vdGlmaWVycykge1xuICAgICAgICAgICAgbm90aWZpZXJzID0gbmV3IE1hcCgpXG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKERlY29kZXJNZXRhZGF0YUtleXMuZGVjb2Rlck5vdGlmaWVycywgbm90aWZpZXJzLCB0YXJnZXQuY29uc3RydWN0b3IpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb3BlcnR5Tm90aWZpZXJzID0gbm90aWZpZXJzLmdldChrZXlQYXRoKVxuICAgICAgICBpZiAoIXByb3BlcnR5Tm90aWZpZXJzKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eU5vdGlmaWVycyA9IFtdXG4gICAgICAgICAgICBub3RpZmllcnMuc2V0KGtleVBhdGgsIHByb3BlcnR5Tm90aWZpZXJzKVxuICAgICAgICB9XG4gICAgICAgIHByb3BlcnR5Tm90aWZpZXJzLnB1c2goe1xuICAgICAgICAgICAga2V5OiBrZXlQYXRoLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG1hcEZ1bmN0aW9uOiBkZXNjcmlwdG9yLnZhbHVlIGFzICgodmFsdWU6IGFueSkgPT4gYW55KSB8IHVuZGVmaW5lZCxcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvclxuICAgIH1cbn1cbiJdfQ==