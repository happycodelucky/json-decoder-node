"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonNotify = exports.jsonDecoderCompleted = exports.jsonDecoder = exports.jsonDecoderFactory = exports.jsonType = exports.jsonPropertyAlias = exports.jsonProperty = exports.jsonContext = exports.jsonSchema = exports.jsonDecodable = void 0;
require("reflect-metadata");
const createDebugLog = require("debug");
const decoder_declarations_1 = require("../decoder/decoder-declarations");
const decoder_declarations_2 = require("../decoder/decoder-declarations");
const decoder_map_1 = require("../decoder/decoder-map");
const json_symbols_1 = require("./json-symbols");
const debug = createDebugLog('decoder:json');
function jsonDecodable(options) {
    return (target) => {
        debug(`${target.name} applying jsonDecodable with options ${JSON.stringify(options)}`);
        Reflect.defineMetadata(decoder_declarations_1.DecoderMetadataKeys.decodable, true, target);
        const decodableOptions = Object.assign({}, options);
        Reflect.defineMetadata(decoder_declarations_1.DecoderMetadataKeys.decodableOptions, decodableOptions, target);
        return target;
    };
}
exports.jsonDecodable = jsonDecodable;
function jsonSchema(schema, ...references) {
    return (target) => {
        debug(`${target.name} applying jsonSchema`);
        const schemaMetadata = {
            schema,
            references,
        };
        Reflect.defineMetadata(json_symbols_1.JsonDecoderMetadataKeys.schema, schemaMetadata, target);
        return target;
    };
}
exports.jsonSchema = jsonSchema;
function jsonContext(target, key) {
    debug(`${target.constructor.name} applying jsonContext to ${key}`);
    Reflect.defineMetadata(json_symbols_1.JsonDecoderMetadataKeys.context, key, target.constructor);
    const descriptor = Reflect.getOwnPropertyDescriptor(target, key);
    Reflect.defineProperty(target, key, {
        configurable: true,
        writable: true,
        enumerable: false,
        value: !!descriptor ? descriptor.value : undefined,
    });
    if (!('toJSON' in target)) {
        target['toJSON'] = function toJSON() {
            return Object.assign({}, this[key]);
        };
    }
}
exports.jsonContext = jsonContext;
function jsonProperty(target, key) {
    debug(`${target.constructor.name} applying jsonProperty to ${key}`);
    const decoderMap = decoder_map_1.decoderMapEntryForTarget(key, target.constructor);
    if (typeof decoderMap.key !== 'string' || decoderMap.key.length === 0) {
        decoderMap.key = key;
    }
}
exports.jsonProperty = jsonProperty;
function jsonPropertyAlias(keyPath) {
    if (typeof keyPath !== 'string' || keyPath.length === 0) {
        throw new TypeError('jsonProperty(keyPath) should be a non-empty String');
    }
    return (target, key) => {
        const decoderMap = decoder_map_1.decoderMapEntryForTarget(key, target.constructor);
        decoderMap.key = keyPath;
    };
}
exports.jsonPropertyAlias = jsonPropertyAlias;
function jsonType(type, mapFunction) {
    if (Array.isArray(type) && type.length !== 1) {
        throw new TypeError('jsonType(type) should have exactly one element for Array types');
    }
    return (target, key) => {
        const decoderMapEntry = decoder_map_1.decoderMapEntryForTarget(key, target.constructor);
        const elementType = decoder_declarations_2.isDecoderPrototypalCollectionTarget(type) ? type.collection : type;
        debug(`${target.constructor.name} applying jsonType to ${key}, marshalling using ${elementType.name}`);
        decoderMapEntry.type = type;
        decoderMapEntry.mapFunction = mapFunction;
    };
}
exports.jsonType = jsonType;
function jsonDecoderFactory(target, key, descriptor) {
    debug(`${target.name} applying jsonDecoderFactory to ${key}`);
    Reflect.defineMetadata(decoder_declarations_1.DecoderMetadataKeys.decoderFactory, target[key], target);
    return descriptor;
}
exports.jsonDecoderFactory = jsonDecoderFactory;
function jsonDecoder(target, key, descriptor) {
    debug(`${target.constructor.name} applying jsonDecoder to ${key}`);
    Reflect.defineMetadata(decoder_declarations_1.DecoderMetadataKeys.decoder, target[key], target);
    return descriptor;
}
exports.jsonDecoder = jsonDecoder;
function jsonDecoderCompleted(target, key, descriptor) {
    debug(`${target.constructor.name} applying jsonDecoderCompleted to ${key}`);
    Reflect.defineMetadata(decoder_declarations_1.DecoderMetadataKeys.decoderCompleted, target[key], target);
    return descriptor;
}
exports.jsonDecoderCompleted = jsonDecoderCompleted;
function jsonNotify(keyPath, type) {
    if (typeof keyPath !== 'string') {
        throw new TypeError('jsonPropertyHandler(keyPath) should be a non-empty String');
    }
    if (Array.isArray(type) && type.length !== 1) {
        throw new TypeError('jsonPropertyHandler(type) should have exactly one element for Array types');
    }
    return (target, key, descriptor) => {
        debug(`${target.constructor.name} applying jsonPropertyHandler ${keyPath} to ${key}`);
        let notifiers = Reflect.getOwnMetadata(decoder_declarations_1.DecoderMetadataKeys.decoderNotifiers, target.constructor);
        if (!notifiers) {
            notifiers = new Map();
            Reflect.defineMetadata(decoder_declarations_1.DecoderMetadataKeys.decoderNotifiers, notifiers, target.constructor);
        }
        let propertyNotifiers = notifiers.get(keyPath);
        if (!propertyNotifiers) {
            propertyNotifiers = [];
            notifiers.set(keyPath, propertyNotifiers);
        }
        propertyNotifiers.push({
            key: keyPath,
            type,
            mapFunction: descriptor.value,
        });
        return descriptor;
    };
}
exports.jsonNotify = jsonNotify;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNvbi1kZWNvcmF0b3JzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2pzb24vanNvbi1kZWNvcmF0b3JzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUlBLDRCQUF5QjtBQUV6Qix3Q0FBdUM7QUFFdkMsMEVBQTBIO0FBQzFILDBFQUF3SDtBQUN4SCx3REFBa0Y7QUFFbEYsaURBQXdEO0FBR3hELE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQTtBQTJCNUMsU0FBZ0IsYUFBYSxDQUFDLE9BQThCO0lBQ3hELE9BQU8sQ0FBb0MsTUFBUyxFQUF1QixFQUFFO1FBQ3pFLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLHdDQUF3QyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQTtRQUN0RixPQUFPLENBQUMsY0FBYyxDQUFDLDBDQUFtQixDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUE7UUFHbkUsTUFBTSxnQkFBZ0IscUJBQTZCLE9BQU8sQ0FBQyxDQUFBO1FBQzNELE9BQU8sQ0FBQyxjQUFjLENBQUMsMENBQW1CLENBQUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxDQUFDLENBQUE7UUFLdEYsT0FBNkIsTUFBTSxDQUFBO0lBQ3ZDLENBQUMsQ0FBQTtBQUNMLENBQUM7QUFkRCxzQ0FjQztBQTBCRCxTQUFnQixVQUFVLENBQUMsTUFBMkIsRUFBRSxHQUFHLFVBQTZEO0lBQ3BILE9BQU8sQ0FBb0MsTUFBUyxFQUFLLEVBQUU7UUFDdkQsS0FBSyxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksc0JBQXNCLENBQUMsQ0FBQTtRQUMzQyxNQUFNLGNBQWMsR0FBOEI7WUFDOUMsTUFBTTtZQUNOLFVBQVU7U0FDYixDQUFBO1FBQ0QsT0FBTyxDQUFDLGNBQWMsQ0FBQyxzQ0FBdUIsQ0FBQyxNQUFNLEVBQUUsY0FBYyxFQUFFLE1BQU0sQ0FB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QVUsQ0FBQTtJQUNyQixDQUFDLENBQUE7QUFDTCxDQUFDO0FBakNELGdDQWlDQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGVjb3JhdG9ycyB0byBkZWNsYXJlIG9uIEpTT04gZGVjb2RhYmxlIGNsYXNzZXMsIHByb3BlcnRpZXMsIGFuZCBmdW5jdGlvbnNcbiAqL1xuXG5pbXBvcnQgJ3JlZmxlY3QtbWV0YWRhdGEnXG5cbmltcG9ydCAqIGFzIGNyZWF0ZURlYnVnTG9nIGZyb20gJ2RlYnVnJ1xuXG5pbXBvcnQgeyBEZWNvZGVyQ29uc3RydWN0YWJsZVRhcmdldCwgRGVjb2Rlck1ldGFkYXRhS2V5cywgRGVjb2RlclByb3RvdHlwYWxUYXJnZXQgfSBmcm9tICcuLi9kZWNvZGVyL2RlY29kZXItZGVjbGFyYXRpb25zJ1xuaW1wb3J0IHsgRGVjb2RlclByb3RvdHlwYWxDb2xsZWN0aW9uVGFyZ2V0LCBpc0RlY29kZXJQcm90b3R5cGFsQ29sbGVjdGlvblRhcmdldCB9IGZyb20gJy4uL2RlY29kZXIvZGVjb2Rlci1kZWNsYXJhdGlvbnMnXG5pbXBvcnQgeyBEZWNvZGVyTWFwRW50cnksIGRlY29kZXJNYXBFbnRyeUZvclRhcmdldCB9IGZyb20gJy4uL2RlY29kZXIvZGVjb2Rlci1tYXAnXG5pbXBvcnQgeyBKc29uQ29udmVydGFibGUsIEpzb25PYmplY3QgfSBmcm9tICcuL2pzb24tZGVjb2RhYmxlLXR5cGVzJ1xuaW1wb3J0IHsgSnNvbkRlY29kZXJNZXRhZGF0YUtleXMgfSBmcm9tICcuL2pzb24tc3ltYm9scydcblxuLy8gRGVidWcgbG9nZ2VyXG5jb25zdCBkZWJ1ZyA9IGNyZWF0ZURlYnVnTG9nKCdkZWNvZGVyOmpzb24nKVxuXG4vL1xuLy8gQ2xhc3MgZGVjb3JhdG9yc1xuLy9cblxuLyoqXG4gKiBPcHRpb25zIHByb3ZpZGVkIHRvIGEgYGpzb25EZWNvZGFibGVgIGNsYXNzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSnNvbkRlY29kYWJsZU9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIFN0cmljdCBtb2RlXG4gICAgICovXG4gICAgc3RyaWN0PzogYm9vbGVhblxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlIHdpbGwgY2FsbCB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24gKGRlZmF1bHQpXG4gICAgICogSWYgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpcyBub3QgdGhlbiBubyBUeXBlU2NyaXB0IGluaXRpYWxpemF0aW9uIG9mIHByb3BlcnRpZXMgaXMgcGVyZm9ybWVkXG4gICAgICovXG4gICAgdXNlQ29uc3RydWN0b3I/OiBib29sZWFuXG59XG5cbi8qKlxuICogRGVjbGFyZSBhIGNsYXNzIGFzIGJlaW5nIGRlY29kYWJsZSBmcm9tIGEgSlNPTiBvYmplY3RcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIGRlY29kZXIgb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24ganNvbkRlY29kYWJsZShvcHRpb25zPzogSnNvbkRlY29kYWJsZU9wdGlvbnMpIHtcbiAgICByZXR1cm4gPFQgZXh0ZW5kcyBEZWNvZGVyUHJvdG90eXBhbFRhcmdldD4odGFyZ2V0OiBUKTogVCAmIEpzb25Db252ZXJ0YWJsZSA9PiB7XG4gICAgICAgIGRlYnVnKGAke3RhcmdldC5uYW1lfSBhcHBseWluZyBqc29uRGVjb2RhYmxlIHdpdGggb3B0aW9ucyAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMpfWApXG4gICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoRGVjb2Rlck1ldGFkYXRhS2V5cy5kZWNvZGFibGUsIHRydWUsIHRhcmdldClcblxuICAgICAgICAvLyBEZWNvZGFibGUgb3B0aW9uc1xuICAgICAgICBjb25zdCBkZWNvZGFibGVPcHRpb25zOiBKc29uRGVjb2RhYmxlT3B0aW9ucyA9IHsuLi5vcHRpb25zfVxuICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKERlY29kZXJNZXRhZGF0YUtleXMuZGVjb2RhYmxlT3B0aW9ucywgZGVjb2RhYmxlT3B0aW9ucywgdGFyZ2V0KVxuXG4gICAgICAgIC8vIGNvbnN0IG1hcCA9IGRlY29kZXJNYXBGb3JUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgLy8gVE9ETzogT3V0cHV0IHRoZSBkZWNvZGVyIG1hcCBmb3IgdGhlIHRhcmdldC4gTmVlZHMgdG8gYmUgc2FuaXRpemUgdG8gb3V0cHV0IGNvcnJlY3RseVxuXG4gICAgICAgIHJldHVybiA8VCAmIEpzb25Db252ZXJ0YWJsZT4gdGFyZ2V0XG4gICAgfVxufVxuXG4vKipcbiAqIEpzb24gc2NoZW1hIGFzIHVzZWQgYnkgYSBKU09OIGRlY29kZWFibGUgb2JqZWN0XG4gKiBUT0RPOiBVc2UgYW4gaW50ZXJmYWNlIGRlc2NyaWJpbmcgdGhlIHN1cHBvcnRlZCBzY2hlbWEgdmVyc2lvbiAobm90IGF2YWlsYWJsZSBpbiBhanYpXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSnNvbkRlY29kYWJsZVNjaGVtYSBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgICRzY2hlbWE6IHN0cmluZ1xuICAgICRpZD86IHN0cmluZ1xufVxuXG4vKipcbiAqIEludGVyZmFjZSBmb3Igc2NoZW1hIG1ldGFkYXRhIHNldCBvbiBhIHRhcmdldFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEpzb25EZWNvZGVyU2NoZW1hTWV0YWRhdGEge1xuICAgIHNjaGVtYTogSnNvbkRlY29kYWJsZVNjaGVtYSxcbiAgICByZWZlcmVuY2VzPzogKEpzb25EZWNvZGFibGVTY2hlbWEgfCBEZWNvZGVyUHJvdG90eXBhbFRhcmdldClbXVxufVxuXG4vKipcbiAqIEFuIGFzc29jaWF0ZWQgSlNPTiBzY2hlbWEgdG8gdmFsaWRhdGUgdGhlIEpTT04gd2l0aCBiZWZvcmUgZGVjb2RpbmdcbiAqIFNlZSBodHRwOi8vanNvbi1zY2hlbWEub3JnL1xuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBKU09OIHNjaGVtYSBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0gcmVmZXJlbmNlcyAtIEpTT04gZGVjb2RhYmxlIGNsYXNzZXMgb3Igc2NoZW1hIHJlZmVyZW5jZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25TY2hlbWEoc2NoZW1hOiBKc29uRGVjb2RhYmxlU2NoZW1hLCAuLi5yZWZlcmVuY2VzOiAoSnNvbkRlY29kYWJsZVNjaGVtYSB8IERlY29kZXJQcm90b3R5cGFsVGFyZ2V0KVtdKSB7XG4gICAgcmV0dXJuIDxUIGV4dGVuZHMgRGVjb2RlclByb3RvdHlwYWxUYXJnZXQ+KHRhcmdldDogVCk6IFQgPT4ge1xuICAgICAgICBkZWJ1ZyhgJHt0YXJnZXQubmFtZX0gYXBwbHlpbmcganNvblNjaGVtYWApXG4gICAgICAgIGNvbnN0IHNjaGVtYU1ldGFkYXRhOiBKc29uRGVjb2RlclNjaGVtYU1ldGFkYXRhID0ge1xuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgcmVmZXJlbmNlcyxcbiAgICAgICAgfVxuICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKEpzb25EZWNvZGVyTWV0YWRhdGFLZXlzLnNjaGVtYSwgc2NoZW1hTWV0YWRhdGEsIHRhcmdldClcblxuICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfVxufVxuXG4vL1xuLy8gUHJvcGVydHkgZGVjb3JhdG9yc1xuLy9cblxuLyoqXG4gKiBKU09OIGNvbnRleHQgb2JqZWN0ICh0aGUgb3JpZ2luIEpTT04pIGFzc2lnbmVkIHRvIGRlY29kaW5nIG9iamVjdFxuICogQWxzbyBhZGRlcyBgdG9KU09OKClgIHRvIHJldHVybiB0aGUgZGVjb2RlZCBvYmplY3QgYmFja1xuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIFNldHMgdGhlIG9yaWdpbiBKU09OIHRvIGEgZGVzaWduYXRlZCBjb250ZXh0IHByb3BlcnR5XG4gKiAgIEBqc29uQ29udGV4dFxuICogICBwcml2YXRlIGpzb246IEpzb25PYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25Db250ZXh0PFQgZXh0ZW5kcyBEZWNvZGVyQ29uc3RydWN0YWJsZVRhcmdldCAmIHsgdG9KU09OKCk6IEpzb25PYmplY3QgfT4odGFyZ2V0OiBULCBrZXk6IHN0cmluZykge1xuICAgIGRlYnVnKGAke3RhcmdldC5jb25zdHJ1Y3Rvci5uYW1lfSBhcHBseWluZyBqc29uQ29udGV4dCB0byAke2tleX1gKVxuICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoSnNvbkRlY29kZXJNZXRhZGF0YUtleXMuY29udGV4dCwga2V5LCB0YXJnZXQuY29uc3RydWN0b3IpXG5cbiAgICBjb25zdCBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpXG4gICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6ICEhZGVzY3JpcHRvciA/IGRlc2NyaXB0b3IudmFsdWUgOiB1bmRlZmluZWQsXG4gICAgfSlcblxuICAgIC8vIGRlZmluZWQgdG9KU09OIGlmIG5vdCBhbHJlYWR5IGRlZmluZWRcbiAgICBpZiAoISgndG9KU09OJyBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldFsndG9KU09OJ10gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gey4uLnRoaXNba2V5XX1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBEZWNsYXJlcyBhIEpTT04gZGVjb2RhYmxlIHByb3BlcnR5XG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gVXNlcyAnaW5kZXgnIGZyb20gSlNPTlxuICogICBAanNvblByb3BlcnR5KClcbiAqICAgcHJpdmF0ZSBpbmRleDogbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc29uUHJvcGVydHk8VCBleHRlbmRzIERlY29kZXJDb25zdHJ1Y3RhYmxlVGFyZ2V0Pih0YXJnZXQ6IFQsIGtleTogc3RyaW5nKSB7XG4gICAgZGVidWcoYCR7dGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWV9IGFwcGx5aW5nIGpzb25Qcm9wZXJ0eSB0byAke2tleX1gKVxuXG4gICAgY29uc3QgZGVjb2Rlck1hcCA9IGRlY29kZXJNYXBFbnRyeUZvclRhcmdldChrZXksIHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgaWYgKHR5cGVvZiBkZWNvZGVyTWFwLmtleSAhPT0gJ3N0cmluZycgfHwgZGVjb2Rlck1hcC5rZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlY29kZXJNYXAua2V5ID0ga2V5XG4gICAgfVxufVxuXG4vKipcbiAqIERlY2xhcmVzIGEgSlNPTiBkZWNvZGFibGUgcHJvcGVydHkgd2l0aCBvcHRpb25hbCBrZXkva2V5LXBhdGggYWxpYXNcbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBVc2VzICdpbmRleCcgZnJvbSBKU09OLCBhc3NpZ25lZCB0byAnX2luZGV4J1xuICogICBAanNvblBhdGgoJ2luZGV4JylcbiAqICAgcHJpdmF0ZSBfaW5kZXg6IG51bWJlclxuICpcbiAqICAgLy8gVXNlcyAnaW5kZXhlcycgZnJvbSBKU09OLCB0YWtpbmcgdGhlIGFycmF5IHZhbHVlJ3MgMCBpbmRleFxuICogICBAanNvblBhdGgoJ2luZGV4ZXNbMF0nKSAtIG9yIC0gQGpzb25QYXRoKCdpbmRleGVzQDAnKVxuICogICBwcml2YXRlIGluZGV4OiBudW1iZXJcbiAqXG4gKiAgIC8vIFVzZXMgJ3RhcmdldDogeyBpbmRleCB9JyBmcm9tIEpTT05cbiAqICAgQGpzb25QYXRoKCd0YXJnZXQuaW5kZXgnKVxuICogICBwcml2YXRlIGluZGV4OiBudW1iZXJcbiAqXG4gKiBAcGFyYW0ga2V5UGF0aCAtIHBhdGggdG8gdGhlIHByb3BlcnR5LCBvciB1bmRlZmluZWQgdG8gdXNlIHByb3BlcnR5IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25Qcm9wZXJ0eUFsaWFzKGtleVBhdGg6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycgfHwga2V5UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignanNvblByb3BlcnR5KGtleVBhdGgpIHNob3VsZCBiZSBhIG5vbi1lbXB0eSBTdHJpbmcnKVxuICAgIH1cblxuICAgIHJldHVybiAodGFyZ2V0OiBEZWNvZGVyQ29uc3RydWN0YWJsZVRhcmdldCwga2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgZGVjb2Rlck1hcCA9IGRlY29kZXJNYXBFbnRyeUZvclRhcmdldChrZXksIHRhcmdldC5jb25zdHJ1Y3RvcilcbiAgICAgICAgLy8gVE9ETzogQ29tcGlsZSB0aGUgcGF0aCBoZXJlIGluc3RlYWQgb2YgZWFjaCBkZWNvZGVcbiAgICAgICAgZGVjb2Rlck1hcC5rZXkgPSBrZXlQYXRoXG4gICAgfVxufVxuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgbWFwcyAobWFyc2hhbHMpIGEgdmFsdWUgZnJvbSBhIEpTT04gcHJvcGVydHkgdmFsdWUgaW50byBhIGRlc2lyZWQgdHlwZVxuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIEVuc3VyZXMgYSBOdW1iZXIgdmFsdWUgd2lsbCBiZSBhc3NpZ25lZCB0byAnaW5kZXgnLCBtYXBwZWQgYXBwcm9wcmlhdGVseVxuICogICBAanNvblByb3BlcnR5KClcbiAqICAgQGpzb25UeXBlKE51bWJlcilcbiAqICAgcHJpdmF0ZSBpbmRleDogbnVtYmVyXG4gKlxuICogICAvLyBFbnN1cmVzIGEgVVJMIHZhbHVlIHdpbGwgYmUgYXNzaWduZWQgdG8gJ2VuZHBvaW50JywgbWFyc2hhbGxlZCBmcm9tIGEgc3RyaW5nIGFwcHJvcHJpYXRlbHlcbiAqICAgQGpzb25Qcm9wZXJ0eSgpXG4gKiAgIEBqc29uVHlwZShVUkwpXG4gKiAgIHByaXZhdGUgaW5kZXg6IFVSTFxuICpcbiAqICAgLy8gRW5zdXJlcyB0aGUgZGVjb2RlZCB2YWx1ZSB3aWxsIGJlIGEgc3RyaW5nLCBhbmQgdXNlcyB0aGUgc3RyaW5nIHdpdGggYSBjdXN0b20gbWFwIGZ1bmN0aW9uXG4gKiAgIEBqc29uUHJvcGVydHkoKVxuICogICBAanNvblR5cGUoU3RyaW5nLCAodmFsdWU6IHN0cmluZykgPT4gbmV3IFJlZ0V4LmNvbXBpbGUodmFsdWUpKVxuICogICBwcml2YXRlIHBhdHRlcm46IFJlZ0V4XG4gKlxuICogQHBhcmFtIHR5cGUgLSBtYXJzaGFsbGFibGUgdHlwZVxuICogQHBhcmFtIFttYXBGdW5jdGlvbl0gLSBvcHRpb25hbCBmdW5jdGlvbiB0YWtpbmcgYW4gaW5zdGFuY2Ugb2YgYHR5cGVgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc29uVHlwZShcbiAgICB0eXBlOiBEZWNvZGVyUHJvdG90eXBhbFRhcmdldCB8IERlY29kZXJQcm90b3R5cGFsQ29sbGVjdGlvblRhcmdldCxcbiAgICBtYXBGdW5jdGlvbj86ICh2YWx1ZTogYW55KSA9PiBhbnksXG4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSAmJiB0eXBlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdqc29uVHlwZSh0eXBlKSBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBlbGVtZW50IGZvciBBcnJheSB0eXBlcycpXG4gICAgfVxuXG4gICAgcmV0dXJuICh0YXJnZXQ6IERlY29kZXJDb25zdHJ1Y3RhYmxlVGFyZ2V0LCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBkZWNvZGVyTWFwRW50cnkgPSBkZWNvZGVyTWFwRW50cnlGb3JUYXJnZXQoa2V5LCB0YXJnZXQuY29uc3RydWN0b3IpXG5cbiAgICAgICAgY29uc3QgZWxlbWVudFR5cGUgPSBpc0RlY29kZXJQcm90b3R5cGFsQ29sbGVjdGlvblRhcmdldCh0eXBlKSA/IHR5cGUuY29sbGVjdGlvbiA6IHR5cGVcbiAgICAgICAgZGVidWcoYCR7dGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWV9IGFwcGx5aW5nIGpzb25UeXBlIHRvICR7a2V5fSwgbWFyc2hhbGxpbmcgdXNpbmcgJHtlbGVtZW50VHlwZS5uYW1lfWApXG5cbiAgICAgICAgZGVjb2Rlck1hcEVudHJ5LnR5cGUgPSB0eXBlXG4gICAgICAgIGRlY29kZXJNYXBFbnRyeS5tYXBGdW5jdGlvbiA9IG1hcEZ1bmN0aW9uXG4gICAgfVxufVxuXG4vL1xuLy8gRnVuY3Rpb24gZGVjb3JhdG9yc1xuLy9cblxuLyoqXG4gKiBEZWNsYXJlcyBhIGZ1bmN0aW9uIGFzIGJlaW5nIHRoZSBkZWNvZGVyIGNsYXNzIGZhY3RvcnksIHJldHVybmluZyB0aGUgY2xhc3MgdG8gaW5zdGF0aWF0ZSB3aXRoIHRoZSBKU09OIGRlY29kZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogICBAanNvbkRlY29kZXJGYWN0b3J5XG4gKiAgIHN0YXRpYyBkZWNvZGVyQ2xhc3NGYWN0b3J5KGpzb246IEpzb25PYmplY3QpIHtcbiAqICAgICAgIC8vIElmICd0eXBlJyBpcyAnc3BlY2lhbCcgaW4gb3VyIEpTT04gb2JqZWN0LCByZXR1cm4gTXlTcGVjaWFsQ2xhc3MgdG8gZGVjb2RlXG4gKiAgICAgICBpZiAoJ3R5cGUnIGluIGpzb24gJiYganNvbi50eXBlID09PSAnc3BlY2lhbCcpIHtcbiAqICAgICAgICAgICByZXR1cm4gbmV3IE15U3BlY2lhbENsYXNzKClcbiAqICAgICAgIH1cbiAqXG4gKiAgICAgICByZXR1cm4gTXlDbGFzcygpXG4gKiAgIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25EZWNvZGVyRmFjdG9yeSh0YXJnZXQ6IERlY29kZXJQcm90b3R5cGFsVGFyZ2V0LCBrZXk6IHN0cmluZywgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKTogUHJvcGVydHlEZXNjcmlwdG9yIHtcbiAgICBkZWJ1ZyhgJHt0YXJnZXQubmFtZX0gYXBwbHlpbmcganNvbkRlY29kZXJGYWN0b3J5IHRvICR7a2V5fWApXG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShEZWNvZGVyTWV0YWRhdGFLZXlzLmRlY29kZXJGYWN0b3J5LCB0YXJnZXRba2V5XSwgdGFyZ2V0KVxuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3Jcbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGRlY29kZXIgZnVuY3Rpb24uIFRoaXMgZGVjb3JhdGlvbiBiZWhhdmVzIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB0aGUgcGxhY2VtZW50IG9uIHRoZVxuICogY2xhc3Moc3RhdGljIGZ1bmN0aW9uKS9jb25zdHJ1Y3RvciBmdW5jdGlvbiBpdHNlbGYsIG9yIG9uIHRoZSBjbGFzcyBwcm90b3R5cGUuIEJvdGggbWF5IGJlIHVzZWQsIGlmIGRlc2lyZWQuXG4gKiBJbiBib3RoIGNhc2UgdGhlIHNvdXJjZSBKU09OIG9iamVjdCB3aWxsIGJlIHN1cHBsaWVkIHRvIGFpZCBkZWNvZGluZy5cbiAqXG4gKiBXaGVuIGFwcGxpZWQgdG8gdGhlIGNsYXNzIChzdGF0aWMgZnVuY3Rpb24pIHRoZSBkZWNvZGVyIGZ1bmN0aW9uIG11c3QgcmV0dXJuIHRoZSBkZWNvZGVkIG9iamVjdCwgb3IgaW5pdGlhbGl6ZVxuICogYW5kIG9iamVjdCB0byBiZWdpbiBkZWNvZGluZy4gUmV0dXJuaW5nIHVuZGVmaW5lZCB3aWxsIGZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0IG9iamVjdCBjcmVhdGlvbiwgcmV0dXJuaW5nIG51bGwgd2lsbFxuICogaW52YWxpZGF0ZSBkZWNvZGluZy5cbiAqXG4gKiBXaGVuIGFwcGxpZWQgdG8gYSBwcm90b3R5cGUgZnVuY3Rpb24sIHRoZSBkZWNvZGluZyBvYmplY3Qgd2lsbCBoYXZlIGJlZW4gY3JlYXRlZC4gVGhlIGZ1bmN0aW9uIG11c3QgcmV0dXJuIHRoaXMgb3JcbiAqIGEgcmVwbGFjZW1lbnQgb2JqZWN0LiBSZXR1cm5pbmcgdW5kZWZpbmVkIHdpbGwgZmFsbGJhY2sgYW5kIHVzZSB0aGUgc2FtZSBkZWNvZGluZyBvYmplY3QgYWxyZWFkeSBjcmVhdGVkLCByZXR1cm5pbmdcbiAqIG51bGxsIHdpbGwgaW52YWxpZGF0ZSB0aGUgZGVjb2RpbmcuXG4gKlxuICogRXJyb3JzIHRocm93biBoZXJlIHdpbGwgYmUgcHJvcGFnYXRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAgIEBqc29uRGVjb2RlclxuICogICBwdWJsaWMgZGVjb2Rlcihqc29uOiBPYmplY3QpOiBNeUNsYXNzIHwgbnVsbCB7IC4uLiB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc29uRGVjb2Rlcih0YXJnZXQ6IERlY29kZXJDb25zdHJ1Y3RhYmxlVGFyZ2V0LCBrZXk6IHN0cmluZywgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKTogUHJvcGVydHlEZXNjcmlwdG9yIHtcbiAgICBkZWJ1ZyhgJHt0YXJnZXQuY29uc3RydWN0b3IubmFtZX0gYXBwbHlpbmcganNvbkRlY29kZXIgdG8gJHtrZXl9YClcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKERlY29kZXJNZXRhZGF0YUtleXMuZGVjb2RlciwgdGFyZ2V0W2tleV0sIHRhcmdldClcblxuICAgIHJldHVybiBkZXNjcmlwdG9yXG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBmdW5jdGlvbiBjYWxsZWQgb24gdGhlIGRlY29kZWQgb2JqZWN0IHdoZW4gZGVjb2RpbmcgaGFzIGNvbXBsZXRlZC4gQXQgdGhpcyBwb2ludCBhbGwgcHJvcGVydGllcyBoYXZlXG4gKiBiZWVuIGFzc2lnbmVkLCBhbmQgYWxsIHByb3BlcnR5IGhhbmRsZXIgZnVuY3Rpb25zIGNhbGxlZC4gYGpzb25EZWNvZGVyQ29tcGxldGVkYCBvbmx5IGNhbiBiZSBjYWxsZWQgb24gcHJvdG90eXBlXG4gKiBmdW5jdGlvbnMsIGFuZCBwcm92aWRlcyBhIGxhc3QgY2hhbmNlIHRvIHBlcmZvcm0gYW55IGFkZGl0aW9uYWwgZGVjb2RpbmcsIHZhbGlkYXRpb24sIG9yIGludmFsaWRhdGlvbi5cbiAqXG4gKiBMaWtlIGBqc29uRGVjb2RlcmAgcmV0dXJuaW5nIGBudWxsYCBpbnZhbGlkYXRlcyB0aGUgZGVjb2RlZCBvYmplY3QuXG4gKlxuICogRXJyb3JzIHRocm93biBoZXJlIHdpbGwgYmUgcHJvcGFnYXRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAgIEBqc29uRGVjb2RlckNvbXBsZXRlXG4gKiAgIGZ1bmN0aW9uIGRlY29kZXIoanNvbjogT2JqZWN0KTogTXlDbGFzcyB8IG51bGwgeyAuLi4gfVxuICovXG5leHBvcnQgZnVuY3Rpb24ganNvbkRlY29kZXJDb21wbGV0ZWQodGFyZ2V0OiBEZWNvZGVyQ29uc3RydWN0YWJsZVRhcmdldCwga2V5OiBzdHJpbmcsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcik6IFByb3BlcnR5RGVzY3JpcHRvciB7XG4gICAgZGVidWcoYCR7dGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWV9IGFwcGx5aW5nIGpzb25EZWNvZGVyQ29tcGxldGVkIHRvICR7a2V5fWApXG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShEZWNvZGVyTWV0YWRhdGFLZXlzLmRlY29kZXJDb21wbGV0ZWQsIHRhcmdldFtrZXldLCB0YXJnZXQpXG5cbiAgICByZXR1cm4gZGVzY3JpcHRvclxufVxuXG4vKipcbiAqIEFzc29jaWF0ZXMgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhIEpTT04gcHJvcGVydHkgb2YgYSBnaXZlbiBrZXkgcGF0aCBpcyBmb3VuZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICBqc29uTm90aWZ5KCdpbmRleCcsIE51bWJlcilcbiAqICAgcHJpdmF0ZSBvbkluZGV4KGluZGV4OiBudW1iZXIsIGpzb246IEpzb25PYmplY3QpIHtcbiAqICAgICAvLyBEbyBzb21ldGhpbmcgd2l0aCBpbmRleFxuICogICAgIC8vICd0aGlzJyBpcyBzZXQgdG8gdGhlIG9iamVjdCBiZWluZyBjb2RlZFxuICogICB9XG4gKlxuICogQHBhcmFtIGtleVBhdGggLSBrZXkgcGF0aCB0byB0aGUgcHJvcGVydHkgZnJvbSB0aGUgcm9vdCBmb3IgdGhlIEpTT05cbiAqIEBwYXJhbSBbdHlwZT11bmRlZmluZWRdIC0gdHlwZSBkZWNsYXJhdGlvbiBzaW1pbGFyIHRvIGpzb25UeXBlIHRvIGF1dG9tYXRpY2FsbHkgbWFwIHRoZSBwcm9wZXJ0eSB0b1xuICovXG5leHBvcnQgZnVuY3Rpb24ganNvbk5vdGlmeShrZXlQYXRoOiBzdHJpbmcsIHR5cGU/OiBEZWNvZGVyUHJvdG90eXBhbFRhcmdldCB8IERlY29kZXJQcm90b3R5cGFsQ29sbGVjdGlvblRhcmdldCkge1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignanNvblByb3BlcnR5SGFuZGxlcihrZXlQYXRoKSBzaG91bGQgYmUgYSBub24tZW1wdHkgU3RyaW5nJylcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkgJiYgdHlwZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignanNvblByb3BlcnR5SGFuZGxlcih0eXBlKSBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBlbGVtZW50IGZvciBBcnJheSB0eXBlcycpXG4gICAgfVxuXG4gICAgcmV0dXJuIDxUIGV4dGVuZHMgRGVjb2RlckNvbnN0cnVjdGFibGVUYXJnZXQ+KHRhcmdldDogVCwga2V5OiBzdHJpbmcsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcik6IFByb3BlcnR5RGVzY3JpcHRvciA9PiB7XG4gICAgICAgIGRlYnVnKGAke3RhcmdldC5jb25zdHJ1Y3Rvci5uYW1lfSBhcHBseWluZyBqc29uUHJvcGVydHlIYW5kbGVyICR7a2V5UGF0aH0gdG8gJHtrZXl9YClcblxuICAgICAgICBsZXQgbm90aWZpZXJzID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcbiAgICAgICAgICAgIERlY29kZXJNZXRhZGF0YUtleXMuZGVjb2Rlck5vdGlmaWVycyxcbiAgICAgICAgICAgIHRhcmdldC5jb25zdHJ1Y3RvcixcbiAgICAgICAgKSBhcyBNYXA8c3RyaW5nLCBEZWNvZGVyTWFwRW50cnlbXT4gfCB1bmRlZmluZWRcblxuICAgICAgICBpZiAoIW5vdGlmaWVycykge1xuICAgICAgICAgICAgbm90aWZpZXJzID0gbmV3IE1hcCgpXG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKERlY29kZXJNZXRhZGF0YUtleXMuZGVjb2Rlck5vdGlmaWVycywgbm90aWZpZXJzLCB0YXJnZXQuY29uc3RydWN0b3IpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb3BlcnR5Tm90aWZpZXJzID0gbm90aWZpZXJzLmdldChrZXlQYXRoKVxuICAgICAgICBpZiAoIXByb3BlcnR5Tm90aWZpZXJzKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eU5vdGlmaWVycyA9IFtdXG4gICAgICAgICAgICBub3RpZmllcnMuc2V0KGtleVBhdGgsIHByb3BlcnR5Tm90aWZpZXJzKVxuICAgICAgICB9XG4gICAgICAgIHByb3BlcnR5Tm90aWZpZXJzLnB1c2goe1xuICAgICAgICAgICAga2V5OiBrZXlQYXRoLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG1hcEZ1bmN0aW9uOiBkZXNjcmlwdG9yLnZhbHVlIGFzICgodmFsdWU6IGFueSkgPT4gYW55KSB8IHVuZGVmaW5lZCxcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvclxuICAgIH1cbn1cbiJdfQ==